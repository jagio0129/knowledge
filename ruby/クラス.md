## インスタンスメソッド
- クラス定義内で定義したメソッドは、そのクラスインスタンスに対して呼び出せる。

```rb
class Hoge
	def fuga
		puts 'Hello'
	end
end

o = Hoge.new
o.fuga # => Hello
```

## インスタンス変数
- インスタンスの中でだけ参照できる変数。
- `@hoge`のように@から始まる変数名

```rb
class Ruler
	def length=(val)
		@length = val
	end

	def length
		puts @length
	end
end

o = Ruler.new
o.length = 30
o.length # => 30
```

- rubyではインスタンス変数への代入を行うメソッド名には末尾にイコールをつける。
- 実際に、インスタンス変数にアクセスするメソッドがほしいときには`attr_accessor`を用いる。

```rb
class Ruler
	attr_accessor :length

	def length
		puts @length
	end
end

o = Ruler.new
o.length = 30
o.length # => 30
```

## self
- **そのメソッドが属性しているインスタンス** を指す
- 他の言語の`this`にあたる
- 省略できるなら省略するのが普通
- ただし`Ruler#length=`のようなメソッド呼び出しのselfは省略できない

```rb
class Ruler
	attr_accessor :length

	def set_default_length
		self.length = 30
	end
end

o = Ruler.new
o.set_default_length
puts o.length # => 30
```

## 初期化
- インスタンス生成時に初期化したい場合は`initialize`メソッドを使う
- 多言語のコンストラクタに該当

```rb
class Ruler
	attr_accessor :length

	def initialize(length)
		@length = length
	end
end

o = Ruler.new(10)
puts o.length # => 10
```

## クラスメソッド
- **クラスに対して呼び出すことのできるメソッド**
- メソッド名の前に`self.`を付けて定義

```rb
class Greet
	attr_accessor :name

	def initialize(name)
		@name = name
	end

	def set_name
		"Hello, #{@name}"
	end

	def self.pair
		[Greet.new('Alice'),Greet.new('Bob')]
	end
end

o = Greet.pair
puts o[0].name 	# => Alice
puts o[1].name	# => Bob

puts o[0].set_name	# => Hello, Alice
puts o[1].set_name	# => Hello, Bob

puts Greet.set_name	# => undefined method `set_name' for Greet:Class (NoMethodErroe)
```

- `Greet#set_name`はクラスメソッドではないので、最後の一行はエラーとなる
- クラスメソッドの中での`self`は、そのクラスが属するクラスになる
	- `new`のレシーバ(`Greet`)は省略できる

```rb
def self.pair
	[new('Alice'), new('Bob')]
end
```

## クラス変数
- **クラスとそのインスタンスをスコープした変数**
- `@@`で始まる変数名となる。
- クラス定義内やクラスメソッドから参照できる

```rb
class MyClass
	@@cvar = 'Hello, My class variable!'

	def cvar_in_method
		@@cvar
	end

	def self.cvar_in_class_method
		@@cvar
	end
end

o = MyClass.new
puts o.cvar_in_method		# => 'Hello, My class variable!'

puts MyClass.cvar_in_class_method	# => 'Hello, My class variable!'
```

## 継承
- Rubyは単一継承をサポート
- 継承された方をスーパークラス、継承した方をサブクラスと呼ぶ
- `<`で継承する

```rb
class Parent
	def hello
		puts 'Hello, Parent class!'
	end
end

class Child < Parent
	def hi
		puts 'Hello, Child class!'
	end
end

o = Child.new
o.hello	# => 'Hello, Parent class!'
o.hi		# => 'Hello, Child class!'
```

### オーバーライド
- スーパークラスで既に定義しているメソッドを、サブクラスで再定義すること

```rb
class Parent
	def hello
		puts 'Hello, Parent class!'
	end
end

class Child < Parent
	def hello
		puts 'Hello, Child class!'
	end
end

o = Child.new
o.hello	# => 'Hello, Child class!'
```

- `super`を使うことでスーパークラス内同名メソッドを呼び出すことができる

```rb
class Parent
	def hello
		puts 'Hello, Parent class!'
	end
end

class Child < Parent
	def hello
		super	# Parent#helloが呼び出される
		puts 'Hello, Child class!'
	end
end

o = Child.new
o.hello	# => 'Hello, Parent class!' 'Hello, Child class!'
```

- スーパークラスを知るには`self.superclass`メソッドを使う

```rb
class Parent
end

class Child < Parent
end

# 再帰っぽいので引数に指定したクラスの継承リストを表示
def show_superclass(klass)
	puts klass
	return klass if klass.superclass.nil?
	show_superclass(klass.superclass)
end

show_superclass(Child) # => Child,Parent,Object,BasicObject
show_superclass(Parent) # => Parent,Object,BasicObject

show_superclass("Hello".class) # => String,Object,BasicObject
show_superclass(%W(a,b).class) # => Array,Object,BasicObject

h = {:test => '1'}
show_superclass(h.class) # => Hash,Object,BasicObject
```
