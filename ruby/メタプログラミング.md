# メタプログラミング
- メタプログラミングとは
- 動的にメソッドを生成する例
  - attr_accesor getter/setter
- 動的メソッド
  - 動的ディスパッチ
- ゴーストメソッド
- 動的メソッドVSゴーストメソッド
- モンキーパッチ
  - オープンクラス 
  - 例
  - 弊害
   - イントロスペクションによる探索


## メタプログラミングとは
「プログラミングをプログラムする」。動的にメソッドを追加するなどができる。など

## 動的にメソッドを生成する例
`attr_accessor`を例に見ていく。

`attr_accessor`は、インスタンス変数にアクセスするメソッドを作り出す。
```rb
class Parson
  attr_accessor :name, :age
end
```

`attr_accessor`は内部的に次のような処理を行っている

1. 引数にシンボル全てに対して以下の処理を繰り返す。
2. シンボルで指定された名前のメソッドを定義する。そのメソッドはシンボルの名前の先頭に「@」をふかしたインスタンス変数の値を取り出す。
3. シンボルで指定されたメソ度目の後ろに「=」を蒸した名前のメソッドを定義する。そのメソッドは引数を一つ取り、その値をシンボルの名前の先頭に「@」を蒸したインスタンス変数に設定する。

`attr_accesseor`は実際にはCで実装されているが、同じ処理をRuby自体で表現するならば以下のようになる

```rb
class Module
  def attr_accessor(*syms)
    syms.each do |sym|
      class_eval %{
        def #{sym}
          @#{sym}
        end

        def #{sym}=(val)
          @#{sym}=val
        end
      }
    end
  end
end
```

`class_eval`は文字列を受け取って、それをクラスの文脈で評価するメソッド。`%{}`までの間が文字列として`class_eval`に渡されている。

呼び出しの対象となったクラスに`name`という名前で**インスタンス変数@nameの値を取り出すメソッド**を定義し、`name=`という名前で**インスタンス変数@nameの値を設定するメソッド**を定義する。

## オープンクラス
Rubyでは、既に定義されたクラスに対してサイドメソッドを定義し直したり、メソッドを追加することが可能。
定義済みクラスの拡張が可能で、後から拡張することができる機能をRubyでは「オープンクラス」という。
自分で定義したクラス以外にも、Rubyが標準で用意している標準添付クラスにたいしてもオープンクラスによって変更を加えることができる。

Arrayクラスにはもともと`replace`というメソッドが存在していた。
つまり、独自に`replace`メソッドを定義したときに元の`replace`メソッドをオーバーライドしてしまったわけ。
そして他の部分が元のメソッドに依存していたため、他のテストが失敗するという結果になってしまった。

上記のように、クラスへの安易なパッチに否定的な人たちはこのようなコードを`モンキーパッチ`という。
きちんと管理できていると思っても、モンキーパッチを使うときは慎重になった方がいい。グローバルな変更と同じように、モンキーパッチもコードが大きくなると追跡が難しくなる。

モンキーパッチの危険性を最小化するには、独自のメソッドを定義する前に、クラスにある既存のメソッドを慎重に確認すること。それから、ある変更がほかの変更よりも危険度が高いことを意識すること。例えば既存のメソッドを修正するよりも、新しいメソッドを追加するほうが安全だ。

### 参考
- http://itpro.nikkeibp.co.jp/article/COLUMN/20070604/273453/?P=1